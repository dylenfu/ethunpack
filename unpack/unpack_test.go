package unpack_test

import (
	. "github.com/dylenfu/extractor/unpack"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"testing"
)

/*
event RingMined(
        uint                _ringIndex,
        bytes32     indexed _ringHash,
        address             _miner,
        address             _feeRecipient,
        bytes32[]           _orderHashList,
        uint[6][]           _amountsList
    );
*/
func Test_UnpackRingMined(t *testing.T) {
	input := "0x0000000000000000000000000000000000000000000000000000000000000025000000000000000000000000750ad4351bb728cec7d639a9511f9d6488f1e2590000000000000000000000003a49f1f84234615caa46e9c89ad3c53e8f142b6c00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000002f9d79dc73f193704bc066db802716166ad317d8b64087d6139b7379a69810c941d3bfd4cecc604b1a920359f7e4a99846d6a12afca94452bc738ca9269b0d6ff000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000006c6b935b8bbd400000000000000000000000000000000000000000000000000000191e50492dbe5b0600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003a1ec3cf9f56000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000191e50492dbe5b0600000000000000000000000000000000000000000000006c30d3894ef018aaab0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003abfd23ccd275555"
	ringmined := &RingMinedEvent{}

	data := hexutil.MustDecode(input)

	topic := "0xcc19747ed90af514ceb971747e19c22778759b621a6992f141cf6ee7083850e8"
	decodeBytes := hexutil.MustDecode(topic)
	topics := [][]byte{decodeBytes}

	if err := ImplAbi.Unpack(ringmined, "RingMined", data, topics); err != nil {
		t.Fatalf(err.Error())
	}

	ring, fills, err := ringmined.ConvertDown()
	if err != nil {
		t.Fatalf(err.Error())
	}
	t.Logf("ringIndex:%s, ringHash:%s, miner:%s, feeReceipt:%s", ring.RingIndex.String(), ring.Ringhash.Hex(), ring.Miner.Hex(), ring.FeeRecipient.Hex())
	for _, fill := range fills {
		t.Logf("amountS:%s, amountB:%s", fill.AmountS.String(), fill.AmountB.String())
	}
}

/*
func Test_UnpackSubmitRing(t *testing.T) {
	input := "0x0fd2f4910000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003e0000000000000000000000000000000000000000000000000000000000000044000000000000000000000000000000000000000000000000000000000000004a0000000000000000000000000000000000000000000000000000000000000056000000000000000000000000000000000000000000000000000000000000006200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000001b978a1d302335a6f2ebe4b8823b5e17c3c84135000000000000000000000000fe5afa7bff3394359af2d277acc9f00065cdbe2f000000000000000000000000b16051a5c45a2e3f5c8f3e67d5955050914756560000000000000000000000001b978a1d302335a6f2ebe4b8823b5e17c3c84135000000000000000000000000639687b7f8501f174356d3acb1972f749021ccd0000000000000000000000000c5dac9e9dd02c757c6c5b5de414ec70edc1dbe24000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000021e19e0c9bab24000000000000000000000000000000000000000000000000000007ce66c50e2840000000000000000000000000000000000000000000000000000000000005ab9edc6000000000000000000000000000000000000000000000000000000005ae17ac60000000000000000000000000000000000000000000000012299d30e1cae000000000000000000000000000000000000000000000000021b1d417f767e70f7fa000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000025e2e8892cd100000000000000000000000000000000000000000000000000a2a15d09519be00000000000000000000000000000000000000000000000000000000000005ab9edf5000000000000000000000000000000000000000000000000000000005ae17af5000000000000000000000000000000000000000000000000581fbb5b33bb000000000000000000000000000000000000000000000000000025ad786dc49d89b500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000003200000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000005099a212b0b0449197bdd9bee860f776850767c1d051f8213ba257e9534e02f71816c4406fcdb8c68ff9dc6fea83be49c821e871a2cbfd1939fdfb7f0b16a02dd112048baa5e18613b26db1d9377bc02b07276f6ff1273110d71b1461e8c13057e688a9a79d9c31bd1c473f55f59e87599dec7403e300ee1368701818c45868da8170ae2145e6c44e37f1d79af5be1eff51133710e8f4fbf45d1268c4762f1f3900000000000000000000000000000000000000000000000000000000000000053d505c658cecfc5c0f6198d5b302d51e43a3b40c0d80f5275cad9fb49d5d5ce312371f557febd145b6e6cb35bc5451dc836888d5cc8f68ee9048b33898a81979423c046ca94c9c42cf882b33d46d3e2526914e21f2f506d1fa7a598d38a93b2a33a3946467f2bd1f0f7e1c8766b049e6c5b0f1110f119574ec930df51428a1ba022435b86c2dd014c214dc5e3ae244d5e669f8be7b1aacfdd527a46a6c9893fe"

	var ring SubmitRingMethod

	data := hexutil.MustDecode("0x" + input[10:])

	if err := ImplAbi.Unpack(&ring, "submitRing", data); err != nil {
		t.Fatalf(err.Error())
	}

	orders, err := ring.ConvertDown()
	if err != nil {
		t.Fatalf(err.Error())
	}

	for k, v := range orders {
		t.Log(k, "tokenS", v.TokenS.Hex())
		t.Log(k, "tokenB", v.TokenB.Hex())

		t.Log(k, "amountS", v.AmountS.String())
		t.Log(k, "amountB", v.AmountB.String())
		t.Log(k, "validSince", v.ValidSince.String())
		t.Log(k, "validUntil", v.ValidUntil.String())
		t.Log(k, "lrcFee", v.LrcFee.String())
		t.Log(k, "rateAmountS", ring.UintArgsList[k][6].String())

		t.Log(k, "marginSplitpercentage", v.MarginSplitPercentage)
		t.Log(k, "feeSelectionList", ring.Uint8ArgsList[k][0])

		t.Log(k, "buyNoMoreThanAmountB", v.BuyNoMoreThanAmountB)

		t.Log("v", v.V)
		t.Log("s", v.S.Hex())
		t.Log("r", v.R.Hex())
	}

	t.Log("ringminer", ring.MinerId.String())
	t.Log("feeSelection", ring.FeeSelections)
}
*/

/*
func TestExtractorServiceImpl_UnpackWethWithdrawalMethod(t *testing.T) {
	input := "0x2e1a7d4d0000000000000000000000000000000000000000000000000000000000000064"

	var withdrawal ethaccessor.WethWithdrawalMethod

	data := hexutil.MustDecode("0x" + input[10:])

	if err := ethaccessor.WethAbi().UnpackMethodInput(&withdrawal.Value, "withdraw", data); err != nil {
		t.Fatalf(err.Error())
	}

	evt := withdrawal.ConvertDown()
	t.Logf("withdrawal event value:%s", evt.Value)
}

func TestExtractorServiceImpl_UnpackCancelOrderMethod(t *testing.T) {
	input := "0x47a99e43000000000000000000000000b1018949b241d76a1ab2094f473e9befeabb5ead000000000000000000000000529540ee6862158f47d647ae023098f6705210a9000000000000000000000000667b8a1021c324b4f42e77d46f5a7a2a2a3cdfc60000000000000000000000000000000000000000000000000000000000004e2000000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000005a33d324000000000000000000000000000000000000000000000000000000000083d60000000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c8c2ccb736eb22424dee71115565d46a1fcf91beb1b12a59488de2757254051020a9d5b0698742580b4a7ec2090e1f24b8b466be253e162994e4887720446807c"

	var method ethaccessor.CancelOrderMethod

	data := hexutil.MustDecode("0x" + input[10:])

	for i := 0; i < len(data)/32; i++ {
		t.Logf("index:%d -> %s", i, common.ToHex(data[i*32:(i+1)*32]))
	}

	if err := ethaccessor.ProtocolImplAbi().UnpackMethodInput(&method, "cancelOrder", data); err != nil {
		t.Fatalf(err.Error())
	}

	order, cancelAmount, err := method.ConvertDown()
	if err != nil {
		t.Fatalf(err.Error())
	}

	t.Log("owner", order.Owner.Hex())
	t.Log("tokenS", order.TokenS.Hex())
	t.Log("tokenB", order.TokenB.Hex())
	t.Log("amountS", order.AmountS.String())
	t.Log("amountB", order.AmountB.String())
	t.Log("validSince", order.ValidSince.String())
	t.Log("validUntil", order.ValidUntil.String())
	t.Log("lrcFee", order.LrcFee.String())
	t.Log("cancelAmount", method.OrderValues[6].String())
	t.Log("buyNoMoreThanAmountB", order.BuyNoMoreThanAmountB)
	t.Log("marginSplitpercentage", order.MarginSplitPercentage)
	t.Log("v", order.V)
	t.Log("s", order.S.Hex())
	t.Log("r", order.R.Hex())
	t.Log("cancelAmount", cancelAmount)
}

func TestExtractorServiceImpl_UnpackApproveMethod(t *testing.T) {
	input := "0x095ea7b300000000000000000000000045aa504eb94077eec4bf95a10095a8e3196fc5910000000000000000000000000000000000000000000000008ac7230489e80000"

	var method ethaccessor.ApproveMethod

	data := hexutil.MustDecode("0x" + input[10:])
	for i := 0; i < len(data)/32; i++ {
		t.Logf("index:%d -> %s", i, common.ToHex(data[i*32:(i+1)*32]))
	}

	if err := ethaccessor.Erc20Abi().UnpackMethodInput(&method, "approve", data); err != nil {
		t.Fatalf(err.Error())
	}

	approve := method.ConvertDown()
	t.Logf("approve spender:%s, value:%s", approve.Spender.Hex(), approve.Value.String())
}

func TestExtractorServiceImpl_UnpackTransfer(t *testing.T) {
	inputs := []string{
		"0x00000000000000000000000000000000000000000000001d2666491321fc5651",
		"0x0000000000000000000000000000000000000000000000008ac7230489e80000",
		"0x0000000000000000000000000000000000000000000000004c0303a413a39039",
		"0x000000000000000000000000000000000000000000000000016345785d8a0000",
	}
	transfer := &ethaccessor.TransferEvent{}

	for _, input := range inputs {
		data := hexutil.MustDecode(input)

		if err := ethaccessor.Erc20Abi().Unpack(transfer, "Transfer", data, abi.SEL_UNPACK_EVENT); err != nil {
			t.Fatalf(err.Error())
		}

		t.Logf("transfer value:%s", transfer.Value.String())
	}
}

func TestExtractorServiceImpl_UnpackRingMined(t *testing.T) {
	input := "0x0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000750ad4351bb728cec7d639a9511f9d6488f1e2590000000000000000000000003a49f1f84234615caa46e9c89ad3c53e8f142b6c00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000002d5f3eb4410b337628be5372c9c3fc790bcef4113fcb229c296bd2519c41aaed2400e5da365eb5b208ccccc5ca8ed27da8286fbb76139cda77b907234ebd09a93000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000ae56f730e6d840000000000000000000000000000000000000000000000000000286c39e79fdbc4f8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001532b10660c30647ae00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000286c39e79fdbc4f800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001158b4151fad157c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ae56f730e6d840000"
	ringmined := &ethaccessor.RingMinedEvent{}

	data := hexutil.MustDecode(input)

	if err := ethaccessor.ProtocolImplAbi().Unpack(ringmined, "RingMined", data, abi.SEL_UNPACK_EVENT); err != nil {
		t.Fatalf(err.Error())
	}

	_, fills, err := ringmined.ConvertDown()
	if err != nil {
		t.Fatalf(err.Error())
	}
	for _, fill := range fills {
		t.Logf("amountS:%s, amountB:%s", fill.AmountS.String(), fill.AmountB.String())
	}
}

func TestExtractorServiceImpl_UnpackWethDeposit(t *testing.T) {
	input := "0x0000000000000000000000000000000000000000000000000de0b6b3a7640000"
	deposit := &ethaccessor.WethDepositEvent{}

	data := hexutil.MustDecode(input)

	if err := ethaccessor.WethAbi().Unpack(deposit, "Deposit", data, abi.SEL_UNPACK_EVENT); err != nil {
		t.Fatalf(err.Error())
	} else {
		t.Logf("deposit value:%s", deposit.Value.String())
	}
}

func TestExtractorServiceImpl_UnpackTokenRegistry(t *testing.T) {
	input := "0x000000000000000000000000f079e0612e869197c5f4c7d0a95df570b163232b0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000457455448"

	tokenRegistry := &ethaccessor.TokenRegisteredEvent{}

	data := hexutil.MustDecode(input)

	println("====token registry", len(data))

	if err := ethaccessor.WethAbi().Unpack(tokenRegistry, "TokenRegistered", data, abi.SEL_UNPACK_EVENT); err != nil {
		t.Fatalf(err.Error())
	} else {
		t.Logf("TokenRegistered symbol:%s, address:%s", tokenRegistry.Symbol, tokenRegistry.Token.Hex())
	}
}

func TestExtractorServiceImpl_UnpackTokenUnRegistry(t *testing.T) {
	input := "0x000000000000000000000000529540ee6862158f47d647ae023098f6705210a90000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000457455448"

	tokenUnRegistry := &ethaccessor.TokenUnRegisteredEvent{}

	data := hexutil.MustDecode(input)

	println("====token unregistry", len(data))

	if err := ethaccessor.WethAbi().Unpack(tokenUnRegistry, "TokenUnregistered", data, abi.SEL_UNPACK_EVENT); err != nil {
		t.Fatalf(err.Error())
	} else {
		t.Logf("TokenUnregistered symbol:%s, address:%s", tokenUnRegistry.Symbol, tokenUnRegistry.Token.Hex())
	}
}

*/

package unpack_test

import (
	. "github.com/dylenfu/extractor/unpack"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"testing"
)

/*
event RingMined(
        uint                _ringIndex,
        bytes32     indexed _ringHash,
        address             _miner,
        address             _feeRecipient,
        bytes32[]           _orderHashList,
        uint[6][]           _amountsList
    );
*/
func Test_UnpackRingMined(t *testing.T) {
	input := "0x0000000000000000000000000000000000000000000000000000000000000025000000000000000000000000750ad4351bb728cec7d639a9511f9d6488f1e2590000000000000000000000003a49f1f84234615caa46e9c89ad3c53e8f142b6c00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000002f9d79dc73f193704bc066db802716166ad317d8b64087d6139b7379a69810c941d3bfd4cecc604b1a920359f7e4a99846d6a12afca94452bc738ca9269b0d6ff000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000006c6b935b8bbd400000000000000000000000000000000000000000000000000000191e50492dbe5b0600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003a1ec3cf9f56000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000191e50492dbe5b0600000000000000000000000000000000000000000000006c30d3894ef018aaab0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003abfd23ccd275555"
	ringmined := &RingMinedEvent{}

	data := hexutil.MustDecode(input)

	topic := "0xcc19747ed90af514ceb971747e19c22778759b621a6992f141cf6ee7083850e8"
	decodeBytes := hexutil.MustDecode(topic)
	topics := [][]byte{decodeBytes}

	if err := ImplAbi.Unpack(ringmined, "RingMined", data, topics); err != nil {
		t.Fatalf(err.Error())
	}

	ring, fills, err := ringmined.ConvertDown()
	if err != nil {
		t.Fatalf(err.Error())
	}
	t.Logf("ringIndex:%s, ringHash:%s, miner:%s, feeReceipt:%s", ring.RingIndex.String(), ring.Ringhash.Hex(), ring.Miner.Hex(), ring.FeeRecipient.Hex())
	for _, fill := range fills {
		t.Logf("amountS:%s, amountB:%s", fill.AmountS.String(), fill.AmountB.String())
	}
}

func Test_UnpackSubmitRing(t *testing.T) {
	input := "0xe78aadb20000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000003e0000000000000000000000000000000000000000000000000000000000000044000000000000000000000000000000000000000000000000000000000000004a0000000000000000000000000000000000000000000000000000000000000054000000000000000000000000000000000000000000000000000000000000005e00000000000000000000000003acdf3e3d8ec52a768083f718e763727b0210650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000004fca076ea95f4d5b67b89caacc5db3b2e98eda02000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000b94065482ad64d4c2b9252358d746b39e820a58200000000000000000000000066f9ad53743c6dd23ac9f8b806e6c7bad9810ff20000000000000000000000004175015b30ff8d116989cdf61f4c7dba15d422ff0000000000000000000000001b793e49237758dbd8b752afc9eb4b329d5da016000000000000000000000000b94065482ad64d4c2b9252358d746b39e820a582000000000000000000000000120abb19fb0a21bbf808136b56f03a8a1fb0d4c800000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000004562f258e81e10000000000000000000000000000000000000000000000004eca7f499babcfc0000000000000000000000000000000000000000000000000000000000005af38bab000000000000000000000000000000000000000000000000000000005af4dd2b000000000000000000000000000000000000000000000000bfca80c74be60000000000000000000000000000000000000000000000000000451022a192bb7b24000000000000000000000000000000000000000000003f45faff39c03ec00000000000000000000000000000000000000000000000000003733e5498f6df0000000000000000000000000000000000000000000000000000000000005af38784000000000000000000000000000000000000000000000000000000005afcc204000000000000000000000000000000000000000000000006559e97e6f4650000000000000000000000000000000000000000000000003efa770945f35252ffac0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000003200000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000000435da0b3690072855ebc200fa50166aa195ed886608807815c3342567d3480f183891d3a3e4145e3d605d23f939aa86c6ecdae704679a6050cf9af6fd2a164725b52fcb539f73f4cf6b7fe74443d0c4fbff15b974fd3edc61cb8af212de7852e941e1e08a6b308ac63adaa061b154766becbac6713ae04288fa5ef4d9898ef36100000000000000000000000000000000000000000000000000000000000000047706a461965d0dfc13f053cd8c6c91becea1b5e9c2b61df3b09c108b4a78b6fb54a0f0d3114b9bef3c9008f3864813b46ad02f5eba2a4c219235eee72520638537d2b7ee0d41e94b7d21b282a3c022a4210bda7d6f5da3c7c8026e7f31daddbb32a57bf97dcc852d38f2d802bd141e512c068538e263bd6bc52d72666e218cda"

	ring := &SubmitRingMethod{}
	data := hexutil.MustDecode("0x" + input[10:])

	if err := ImplAbi.Unpack(ring, "submitRing", data, [][]byte{}); err != nil {
		t.Fatalf(err.Error())
	}

	for i := 0; i < len(data)/32; i++ {
		t.Logf("index:%d -> %s", i, common.ToHex(data[i*32:(i+1)*32]))
	}

	orders, err := ring.ConvertDown()
	if err != nil {
		t.Fatalf(err.Error())
	}

	for k, v := range orders {
		t.Log(k, "owner", v.Owner.Hex())
		t.Log(k, "auth", v.AuthAddr.Hex())
		t.Log(k, "tokenS", v.TokenS.Hex())
		t.Log(k, "tokenB", v.TokenB.Hex())

		t.Log(k, "amountS", v.AmountS.String())
		t.Log(k, "amountB", v.AmountB.String())
		t.Log(k, "validSince", v.ValidSince.String())
		t.Log(k, "validUntil", v.ValidUntil.String())
		t.Log(k, "lrcFee", v.LrcFee.String())
		t.Log(k, "marginSplitpercentage", v.MarginSplitPercentage)

		t.Log(k, "buyNoMoreThanAmountB", v.BuyNoMoreThanAmountB)

		t.Log(k, "v", v.V)
		t.Log(k, "s", v.S.Hex())
		t.Log(k, "r", v.R.Hex())
	}

	t.Log("feeReceipt", ring.FeeRecipient.Hex())
	t.Log("feeSelection", ring.FeeSelections)
}

func Test_UnpackDepositMethod(t *testing.T) {
	input := "0x0000000000000000000000000000000000000000000000000de0b6b3a7640000"
	deposit := &WethDepositMethod{}

	data := hexutil.MustDecode("0x" + input[10:])
	if err := WethAbi.Unpack(deposit, "deposit", []byte{}, [][]byte{data}); err != nil {
		t.Fatalf(err.Error())
	}

	evt := deposit.ConvertDown()
	t.Logf("deposit method value:%s", evt.Value.String())
}

func Test_UnpackWithdrawalMethod(t *testing.T) {
	input := "0x2e1a7d4d0000000000000000000000000000000000000000000000000000000000000064"

	withdrawal := &WethWithdrawalMethod{}
	data := hexutil.MustDecode("0x" + input[10:])

	if err := WethAbi.Unpack(withdrawal, "withdraw", data, [][]byte{}); err != nil {
		t.Fatalf(err.Error())
	}

	evt := withdrawal.ConvertDown()
	t.Logf("withdrawal method value:%s", evt.Value.String())
}

func Test_UnpackCancelOrderMethod(t *testing.T) {
	input := "0x8bc12fd1000000000000000000000000a44282db26ec80c6cfdd748ec09f386a64d645bd000000000000000000000000639687b7f8501f174356d3acb1972f749021ccd0000000000000000000000000fe5afa7bff3394359af2d277acc9f00065cdbe2f000000000000000000000000e62d15a9345b3c00f637fbf4dd08d532101c452b0000000000000000000000000000000000000000000000000c06e364b5b2600000000000000000000000000000000000000000000000003635c9adc5dea00000000000000000000000000000000000000000000000000000000000005abf27bd000000000000000000000000000000000000000000000000000000005ae6b4bd00000000000000000000000000000000000000000000000018904d9f44710000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000003635c9adc5dea0000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000001c6a5a787d7772a16738a554a2f99ed4ae15de26118401f503649df7192f7361c7245be1280754d2331ab210081998cb6be95fdf23330cc1eab1eb7ec88e64293b"

	method := &CancelOrderMethod{}
	data := hexutil.MustDecode("0x" + input[10:])

	if err := ImplAbi.Unpack(method, "cancelOrder", data, [][]byte{}); err != nil {
		t.Fatalf(err.Error())
	}

	order, cancelAmount, err := method.ConvertDown()
	if err != nil {
		t.Fatalf(err.Error())
	}

	t.Log("owner", order.Owner.Hex())
	t.Log("tokenS", order.TokenS.Hex())
	t.Log("tokenB", order.TokenB.Hex())
	t.Log("amountS", order.AmountS.String())
	t.Log("amountB", order.AmountB.String())
	t.Log("validSince", order.ValidSince.String())
	t.Log("validUntil", order.ValidUntil.String())
	t.Log("lrcFee", order.LrcFee.String())
	t.Log("cancelAmount", method.OrderValues[6].String())
	t.Log("buyNoMoreThanAmountB", order.BuyNoMoreThanAmountB)
	t.Log("marginSplitpercentage", order.MarginSplitPercentage)
	t.Log("v", order.V)
	t.Log("s", order.S.Hex())
	t.Log("r", order.R.Hex())
	t.Log("cancelAmount", cancelAmount)
}

func Test_UnpackCancelOrderEvent(t *testing.T) {
	input := "0x00000000000000000000000000000000000000000000003635c9adc5dea00000"
	topic := "0xa9f927dbef0522016b9168807ce7840d3e09faa5520291a9b0eb6748b439a436"

	cancel := &OrderCancelledEvent{}
	data := hexutil.MustDecode(input)
	decodeValues := [][]byte{hexutil.MustDecode(topic)}

	if err := ImplAbi.Unpack(cancel, "OrderCancelled", data, decodeValues); err != nil {
		t.Fatal(err.Error())
	}

	evt := cancel.ConvertDown()

	t.Logf("orderhash:%s", evt.OrderHash.Hex())
	t.Logf("cancelledAmount:%s", evt.AmountCancelled.String())
}

func Test_UnpackApproveMethod(t *testing.T) {
	input := "0x095ea7b30000000000000000000000004e9d4d3b7db4973c91b23a634eb9f675d0e19f790000000000000000000000000000000006f05b59d3b1ffffe43e9298b1380000"

	method := &ApproveMethod{}
	data := hexutil.MustDecode("0x" + input[10:])
	if err := Erc20Abi.Unpack(method, "approve", data, [][]byte{}); err != nil {
		t.Fatalf(err.Error())
	}

	approve := method.ConvertDown()
	t.Logf("approve spender:%s, value:%s", approve.Spender.Hex(), approve.Value.String())
}

func Test_UnpackTransfer(t *testing.T) {
	input := "0x0000000000000000000000000000000000000000000000001d012bed3c90ff00"
	topic1 := "0x000000000000000000000000a44282db26ec80c6cfdd748ec09f386a64d645bd"
	topic2 := "0x0000000000000000000000003a49f1f84234615caa46e9c89ad3c53e8f142b6c"

	transfer := &TransferEvent{}
	data := hexutil.MustDecode(input)
	decodedValues := [][]byte{hexutil.MustDecode(topic1), hexutil.MustDecode(topic2)}
	if err := Erc20Abi.Unpack(transfer, "Transfer", data, decodedValues); err != nil {
		t.Fatalf(err.Error())
	}

	evt := transfer.ConvertDown()
	t.Logf("transfer event value:%s sender:%s, receiver:%s", evt.Value.String(), evt.Sender.Hex(), evt.Receiver.Hex())
}

func Test_UnpackTokenRegistry(t *testing.T) {
	input := "0x000000000000000000000000f079e0612e869197c5f4c7d0a95df570b163232b0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000457455448"

	tokenRegistry := &TokenRegisteredEvent{}
	data := hexutil.MustDecode(input)

	if err := TokenRegistryAbi.Unpack(tokenRegistry, "TokenRegistered", data, [][]byte{}); err != nil {
		t.Fatalf(err.Error())
	}
	t.Logf("TokenRegistered symbol:%s, address:%s", tokenRegistry.Symbol, tokenRegistry.Token.Hex())
}

func Test_UnpackTokenUnRegistry(t *testing.T) {
	input := "0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000034c5243"
	topics := []string{
		"0xee98311a96660ce4ab10cd82053f767653901305ec8acf91ec60311de919e28a",
		"0x000000000000000000000000ae79693db742d72576db8349142f9cd8b9d85355",
	}
	var decodeTopics [][]byte
	decodeTopics = append(decodeTopics, hexutil.MustDecode(topics[0]))
	decodeTopics = append(decodeTopics, hexutil.MustDecode(topics[1]))

	tokenUnRegistry := &TokenUnRegisteredEvent{}
	data := hexutil.MustDecode(input)
	if err := TokenRegistryAbi.Unpack(tokenUnRegistry, "TokenUnregistered", data, decodeTopics); err != nil {
		t.Fatalf(err.Error())
	}
	t.Logf("TokenUnregistered symbol:%s, address:%s", tokenUnRegistry.Symbol, tokenUnRegistry.Token.Hex())
}
